### [242. 有效的字母异位词 - 力扣（LeetCode）](https://leetcode-cn.com/problems/valid-anagram/)

1. 这道题目适用hash结构可以将算法的复杂度降到$O(n)$，更精进一层，如果遇到这种紧紧关心某些内容的统计差异（不涉及顺序比较）的比较就可以使用hash结构，借助hash的查找迅速的有点，将遍历的复杂度降到常数级别。另外，hash结构明显适用于“分类计数”的操作，比如我们有若干西红柿，若干黄瓜，若干茄子，使用hash统计每个品类的数量就可以适用hash遍历。
2. 这道题还有一个补充条件，字符串中仅有小写字母，那么使用长度为26的数组统计数字，代替hash表，在查询和创建性能上有优势。

### [49. 字母异位词分组 - 力扣（LeetCode）](https://leetcode-cn.com/problems/group-anagrams/)

这道题是上面题目的升级版，题目的难点在于如何将一堆物品按类别分好？每个分类好的物品具有相同的某种特征（相同的异位词），所以可以将这种特征作为hash表的键，

1. 遍历每个字符串，提取该字符串的特征（sort之后的字符串）；
2. 特征是否在hash中，没有则新建键，有的话则在特征后面append该字符串

### [239. 滑动窗口最大值 - 力扣（LeetCode）](https://leetcode-cn.com/problems/sliding-window-maximum/)

通过这道题

1. 学会了双端队列这个新的数据结构，双端队列实际上也是队列，与普通的队列数据结构相比，最大不同是它可以在**队首和队尾删除和添加元素**，该数据结构的操作如下图所示

![](https://img-blog.csdnimg.cn/20190503182109249.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pZWk1aTV8=,size_16,color_FFFFFF,t_70)

2. 这道题为什么可以使用双端队列？

   可以这么想，正常情况下需要维护一个长度为`k`的窗口，就是截取原来数组的一段放在里面，然后遍历之后找到最大值。实际上可以更近一步，维护一个队列，队列中保存的是**当前窗口以及后续窗口可能的候选最大值**，也就是说，如果某个元素无法成为候选最大值的话就从队列中剔除。如果以上面的数组为例，明显第一个窗口中的只需要7入队即可，因为1和4不是当前窗口的最大值，也不能成为后续窗口的最大值。然后窗口移动，元素6比7小，入队，因为6可能是（6,2,5）这个窗口的最大值，再向右移动，2比6小，依然入队，再向右移动，7出队，5比2大，所以2不可能成为当前窗口已经后续窗口的最大值了，弹出，5入队。所以这个算法的核心就是**维护单调递减队列**，队首是当前窗口的最大值，窗口移动之后出队移出窗口的元素，如果新元素比队尾的数大，队尾出队，直到队尾比新元素大，新元素入队。

 