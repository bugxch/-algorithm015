## 学习笔记

本周主要练习高级动态规划和字符串的题目，我还是针对做过的题目具体总结一下（所有题目的代码可以参考code文件夹中的`main.cpp`文件）。

### [438. 找到字符串中所有字母异位词 - 力扣（LeetCode）](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)

这道题目规定的字母异位词是将原来的字符顺序打乱的新字符串，因为跟原来的字符长度相同，所以这道题实际上可以使用双指针或者滑动窗口的方法来完成。维护一个滑动窗口，

1. 依次从左到右遍历目标字符串，将目标字符逐渐添加到滑动窗口中；
2. 窗口伸缩的算法如下：
   - 如果当前的字符是参考字符串中的字符，那么就将该字符添加到滑动窗口中，滑动窗口向右扩张
     - 判断当前该字符的数目是否已经和参考字符的数目相等，相等则该字符的匹配满足条件，每次在添加新字符时判断在字符是否满足条件，如果所有字符满足条件，那么就判断当前窗口的长度是否和参考字符相同，如果相同，则记录窗口的起始位置
   - 如果当前字符不是参考字符，那么滑动窗口保持不变；
   - 滑动窗口的字符如果是参考字符，那么记录结果，滑动窗口左移一位（窗口收缩）

因为只要遍历一次就能得到答案，所以算法的复杂度是$O(n)$。

### [387. 字符串中的第一个唯一字符 - 力扣（LeetCode）](https://leetcode-cn.com/problems/first-unique-character-in-a-string/)

我的算法比较简单，

1. 使用hash结构遍历字符串，记录每个字符出现的次数；
2. 再次遍历原来的字符串，每次遍历查阅之前建立hash表，如果该字符的数量为1，就直接返回当前字符的idx，这样就能保证得到第一个唯一字符的索引值。

### [91. 解码方法 - 力扣（LeetCode）](https://leetcode-cn.com/problems/decode-ways/)

这道题目比较难的是定义dp和状态转移方程，我定义`dp[i]`表示解码`S[0,...,i - 1]`的子串的方法，最后问题的答案就是`dp[n]`，其中`n`是字符串的长度。那么使用动态规划的思想，有如下的步骤：

1. 初始化base case，该题目中`dp[0] = dp[1] = 1`，表示长度为1的字符串解码方法只有1种；

2. 找到递推公式，也就是假定前面`i`个字符的解码方法是`dp[i]`个，求`dp[i + 1]`为多少？可以想象一下，类似与下面的字符，S = "121"，如果后面多了一个字符S = "121x"，那么新字符的解码方法可以由两部分组成：

   - S = "121" + "x"，那么`dp[i + 1]= dp[i]`；
   - S = "12" + "1x"，那么`dp[i + 1] = dp[i - 1]`；

   所以`dp[i + 1] = dp[i - 1] + dp[i]`。但是需要注意这里有个前提，**x和1x都必须是合法字符**，所谓合法字符指的是可以映射成字母的字符，比如28整体就不能映射成任何字母，所以是非法字符，如果都不合法，那说明当前字符串的后面两个字符不能映射成任何字符，所以只能返回0。

